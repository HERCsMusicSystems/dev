;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2005 Robert P. Wolf ;;
;;        ALL RIGHTS RESERVED        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

import studio
import conductor
import midi

program help [help helper commands tutorials syntax syntax_helper remove_demo command_helper midi_helper orakle_help MIDI_HELPER set_colors]

[[set_colors *foreground *background] [foreground *foreground] [background *background]]
[[helper *x *y]
	[set_colors 16777215 0] [write *x] [set_colors 65280 0] [write *y]
	]

[[tutorials] [write "This section is empty at the moment.\n"]]

[[help]
	[nl]
	[set_colors *foreground *background]
	[set_colors 16777215 255]
	[write "Quick help:"] [set_colors *foreground *background] [nl]
	[helper "	[help syntax]       " "-to know more about the PROLOG syntax.\n"]
	[helper "	[help commands]     " "-to list all the predefined commands.\n"]
	[helper "	[help <command>]    " "-to get the help on the specified command\n"]
	[helper "	                    " " (i.e. help [sum] will describe the sum command).\n"]
	[helper "	[help midi]         " "-to list all the midi commands.\n"]
	[helper "	[help exit]         " "-to find how to close the program.\n"]
	[set_colors *foreground *background]
	]
[[orakle_help]
	[set_colors *foreground *background]
	[set_colors 16777215 255]
	[write "To get more help type one of the following commands:"] [set_colors *foreground *background] [nl]
	[helper "	[help syntax]       " "-to know more about the PROLOG syntax.\n"]
	[helper "	[help commands]     " "-to list all the predefined commands.\n"]
	[helper "	[help <command>]    " "-to get the help on the specified command\n"]
	[helper "	                    " " (i.e. help [sum] will describe the sum command).\n"]
	[helper "	[help midi]         " "-to list all the midi commands.\n"]
	[helper "	[help exit]         " "-to find how to close the program.\n"]
	[helper "	[help remove_demo]  " "-to find how to remove demo from the start-up.\n"]
	[helper "	[tutorials]         " "-to access tutorials manu.\n"]
	[set_colors *foreground *background]
	]

[[syntax_helper *head *tail]
	[set_colors 16777215 0] [write *head]
	[set_colors 16711680 0] [write " ::=	"]
	[set_colors 65280 0] [write *tail] [nl]
	]
[[help syntax]
	[set_colors *foreground *background]
	[syntax_helper "<command>" "<list> | <atom> <list>"]
	[syntax_helper "<program>" "{import ( <atom> | <text> ) }"]
	[write "		program <atom> [ #machine := <text> ] ( #auto | <atoms> )\n"]
	[write "		{ (\n"]
	[write "			<machine> |\n"]
	[write "			<clause> | auto := <clause> |\n"]
	[write "			<preprocessor> |\n"]
	[write "			protect <atoms> |\n"]
	[write "			private <atoms>\n"]
	[write "		) }\n"]
	[write "		end [ := <clause> ] .\n"]

	[syntax_helper "<atom>		" "( \"_\" | <letter> ) { ( \"_\" | <letter> | <cipher> ) }"]
	[syntax_helper "<atoms>		" "\"[\" { <atom> } \"]\""]
	[syntax_helper "<positive>	" "<cipher> { <cipher> }"]
	[syntax_helper "<number>	" "[ \"-\" ] <positive>"]
	[syntax_helper "<float>		" "<number> . <positive>"]
	[syntax_helper "<text>		" "\"\\\"\" { <anything> } \"\\\"\""]
	[syntax_helper "<variable>	" "\"*\" { ( \"_\" | <letter> | <cipher> ) }"]
	[syntax_helper "<element>	" "<atom> | <number> | <float> | <text> |"]
	[write "			/ | fail | <list> | <variable>\n"]
	[syntax_helper "<tail>		" "{ <element> } [ : <element> ] \"]\""]
	[syntax_helper "<list>		" "\"[\" <element> <tail>"]
	[syntax_helper "<clause>	" "\"[[\" <atom> <tail> <tail>"]
	[syntax_helper "<machine>	" "#machine <atom> := <text>"]
	[syntax_helper "<preprocessor>	" "preprocessor := ( <atom> | \"[\" \"]\" )"]
	[set_colors *foreground *background]
	]

[[help commands]
	[set_colors *foreground *background]
	[set_colors 16777215 255]
	[write "Arithmetic and Logic:"]
	[set_colors 16777215 0] [nl]
	[write "	add	sub	mult	div	mod	sum	times	abs\n"]
	[write "	e	pi	cos	sin	tan	exp	pow	trunc\n"]
	[write "	and	or	xor	log	log2	log10	ln	series\n"]
	[write "	less	less_eq	greater	greater_eq	rnd	grnd	rnd_control\n"]

	[set_colors 16777215 255]
	[write "Input / Output:"]
	[set_colors 16777215 0] [nl]
	[write "	pr	read	readln	write	nl	pp	pt	list\n"]
	[write "	import	load	consult	reload	batch	file_writer	file_reader\n"]
	[write "	cd	dir	edit	move	copy	remove_module	create_module\n"]
	[write "	make_file	make_directory	erase	erase_directory	set_machine\n"]
	[write "	root_directory	search_directories	add_search_directory	crd\n"]

	[set_colors 16777215 255]
	[write "Clause and Atome manipulation:"]
	[set_colors 16777215 0] [nl]
	[write "	CL	DELCL	cl	let	OVERWRITE	overwrite\n"]
	[write "	addcl	addcl0	lambda	delcl	delallcl	auto_atoms\n"]
	[write "	create_atom	search_atom	scripted_atoms	prompt	preprocessor\n"]

	[set_colors 16777215 255]
	[write "Term checks and manipulation:"]
	[set_colors 16777215 0] [nl]
	[write "	is_atom	is_var	is_text	is_head	is_number	is_integer\n"]
	[write "	text_list	text_term	is_double	e23	has_machine\n"]

	[set_colors 16777215 255]
	[write "Real Time:"]
	[set_colors 16777215 0] [nl]
	[write "	tempo	atempo	accel	rit	mutex	timeout		timestamp\n"]
	[write "	wait	wt	beat	bar	metrum	division	conductor\n"]
	[write "	start	pause	stop	reset	signal	signal_bar	signal_beat\n"]
	[write "	enter	accept	select	task	monitor	semaphore	critical_section\n"]

	[set_colors 16777215 255]
	[write "Methalogical:"]
	[set_colors 16777215 0] [nl]
	[write "	res	crack	not	eq	TRY	ONE	ALL	PROBE	inc	dec\n"]
	[write "	FOR	IF	SELECT	APPEND	ISALL	isall	isallr	var	command\n"]
	[write "	WHILE	FOREVER	CONSTANT	VARIABLE	CLOSURE	ACCUMULATOR\n"]
	[write "	ARRAY	LENGTH	REVERSE	MAP	lazy	call	BLOCK	exit	maximise\n"]
	[write "	NODUP	ONLIST	INLIST	closure		rres	ures	sort	minimise\n"]

	[set_colors *foreground *background]
]

[[help midi]
	[set_colors *foreground *background]
	[set_colors 16777215 255]
	[write "MIDI input processor:"]
	[set_colors 16777215 0] [nl]
	[write "	income_midi\n"]
	[set_colors 16777215 255]
	[write "MIDI commands:"]
	[set_colors 16777215 0] [nl]
	[write "	keyon	keyoff	programchange	timingclock	sysex	SYSEX\n"]
	[write "	pitch	control	aftertouch	polyaftertouch	sysexch	SYSEXCH\n"]

	[set_colors 16777215 255]
	[write "MIDI standard controllers:"]
	[set_colors 16777215 0] [nl]
	[write "	attack	release	holdon	holdoff	cutoff	resonance\n"]
	[write "	mono	poly	bank	banklsb	portaon	portaoff	portatime\n"]
	[write "	volume	reverb	chorus	foot	pan	breath		modulation\n"]

	[set_colors 16777215 255]
	[write "MIDI 14-bit controllers:"]
	[set_colors 16777215 0] [nl]
	[write "	CONTROL	ATTACK	RELEASE	CUTOFF	RESONANCE	PORTATIME\n"]
	[write "	VOLUME	REVERB	CHORUS	FOOT	PAN	BREATH	MODULATION\n"]


	[set_colors 16777215 255]
	[write "MIDI macros:"]
	[set_colors 16777215 0] [nl]
	[write "	nrpn	rpn	NRPN	RPN	hit	egcopy	DCMOD\n"]
	[write "	egcopy_index	egcopy_freq	egcopy_amp	egcopy_pan\n"]


	[set_colors *foreground *background]
]

[[help remove_demo]
	[set_colors *foreground *background]
	[set_colors 16777215 255]
	[write "Instructions on how to remove demo from the start-up:\n"]
	[set_colors 65280 0]
	[write "1. Find the \"config.txt\" file in HERCs' root directory.\n"]
	[write "2. Edit the \"config.txt\" file using a simple text editor (i.e. NOTEPAD).\n"]
	[write "3. Inside locate the following line:\n"]
	[set_colors 16777215 0]
	[write "	prolog_library_load [\"demo.prc\"]\n"]
	[set_colors 65280 0]
	[write "4. Remove this line completely.\n"]
	[write "5. Save and close the \"config.txt\" file.\n"]
	[set_colors *foreground *background]
]

; commands

[[command_helper *x]
	[set_colors *foreground *background]
	[set_colors 16777215 255]
	[write *x]
	[set_colors *foreground *background] [nl] /
]

[[help exit]
	[command_helper "exit []"]
	[write "This command is used to close the program.\n"]
	[write "Works only if issued as a command (i.e. exit []).\n"]
	[write "In any other context (i.e. res [[exit]]) does nothing.\n"]
]

[[help add]
	[command_helper "add [*x1 *x2 *x3 ... *xn *result]\nadd [*result *x1 *x2 *x3 ... *xn]\nadd [*x1 *x2 *x3 ... *xn : *result]"]
	[write "Adds all the parameters.\n"]
	[write "The parameters can be integers, floats, atoms or texts.\n"]
	[write "The first or the last parameter must be a variable.\n"]
]

[[help sub]
	[command_helper "sub [*x *y *z]\nsub [*x *y : *z]"]
	[write "Subtracts *y from *x resulting in *z.\n"]
	[write "The parameters can be integers or floats.\n"]
	[write "The first two can not be variables.\n"]
]

[[help mult]
	[command_helper "mult [*x1 *x2 *x3 ... *xn *result]\nmult [*result *x1 *x2 *x3 ... *xn]\nmult [*x1 *x2 *x3 ... *xn : *result]"]
	[write "Multiplies *x by *y resulting in *z.\n"]
	[write "The parameters can be integers or floats.\n"]
	[write "The first or the last parameter must be a variable.\n"]
]

[[help div]
	[command_helper "div [*x *y *z]\ndiv [*x *y : *z]"]
	[write "Divides *x by *y resulting in *z.\n"]
	[write "The parameters can be integers or floats.\n"]
	[write "The first two parameters can not be variables\nand the second parameter can not be zero.\n"]
]

[[help mod]
	[command_helper "mod [*x *y *z]\nmod [*x *y : *z]\nmod [*x *y *z *dv]"]
	[write "Calculates the remainder from the division of *x by *z.\n"]
	[write "Works on integer and double parameters.\n"]
	[write "The first two parameter can not be variables\nand the second parameter can not be zero.\n"]
	[write "The third form calculates both division (*dv) and remainder (*z).\n"]
]

[[help sum]
	[command_helper "sum [*x *y *z]\nsum [*x *y : *z]"]
	[write "Adds or subtracts depending on parameters.\n"]
	[write "Works on integer and float parameters.\n"]
	[write "Only one parameter can be variable.\n"]
]

[[help times]
	[command_helper "times [*x *y *z]\ntimes [*x *y : *z]"]
	[write "Multiplies or divides depending on parameters.\n"]
	[write "Works on integer and float parameters.\n"]
	[write "Only one parameter can be variable.\n"]
	[write "Fails if division by zero.\n"]
]

[[help abs]
	[command_helper "abs [*x *y]\nabs [*x : *y]"]
	[write "Calculates the absolute value of *x.\n"]
	[write "*x can be integer or float,\n"]
	[write "*y is always of the same type as *x\n"]
	]
[[help degrad]
	[command_helper "degrad [*deg *rad]\ndegrad [*deg : *rad]"]
	[write "Changes degrees to radians and vice-versa.\n"]
	]
[[help cos]
	[command_helper "cos [*x *y]\ncos [*x : *y]"]
	[write "Calculates the cos of *x or arc cos of *y.\n"]
	[write "The angle can be in radians (*x is Double)\nor in degrees (*x is Integer).\n"]
	[write "For arc cos *y must be in range -1 .. 1\nand always returns radians.\n"]
	]
[[help sin]
	[command_helper "sin [*x *y]\nsin [*x : *y]"]
	[write "Calculates the sin of *x or arc sin of *y.\n"]
	[write "The angle can be in radians (*x is Double)\nor in degrees (*x is Integer).\n"]
	[write "For arc sin *y must be in range -1 .. 1\nand always returns radians.\n"]
	]
[[help tan]
	[command_helper "tan [*x *y]\ntan [*x : *y]"]
	[write "Calculates the tan of *x or arc tan of *y.\n"]
	[write "The angle can be in radians (*x is Double)\nor in degrees (*x is Integer).\n"]
	[write "For arc tan the result is always in radians.\n"]
	]
[[help log2]
	[command_helper "log2 [*x *y]\nlog2 [*x : *y]"]
	[write "Calculates the binary (base=2) logarithm of *x.\n"]
	]
[[help log10]
	[command_helper "log10 [*x *y]\nlog10 [*x : *y]"]
	[write "Calculates the decimal (base=10) logarithm of *x.\n"]
	]
[[help ln]
	[command_helper "ln [*x *y]\nln [*x : *y]"]
	[write "Calculates the natural (base=e) logarithm of *x.\n"]
	]
[[help log]
	[command_helper "log [*x *y *z]\nlog [*x *y : *z]"]
	[write "Calculates the *x-based logarithm of *y.\n"]
	]
[[help exp]
	[command_helper "exp [*x *y]\nexp [*x : *y]"]
	[write "Calculates the exponential value of *x.\n"]
	]
[[help pow]
	[command_helper "pow [*x *y *z]\npow [*x *y : *z]"]
	[write "Multipurpose procedure.\n"]
	[write "Calculates either:\n"]
	[write "	*x raised to the power of *y.\n"]
	[write "	*y-root of *z\n"]
	[write "	*x-based logarithm of *z\n"]
	[write "If two supplied arguments are integer\n"]
	[write "then the result is truncated to integer as well.\n"]
	]
[[help trunc]
	[command_helper "trunc [*x *y]	[trunc *a : *b]"]
	[write "Truncates float *x to integer *y or\n"]
	[write "typecasts integer *y to float *x or\n"]
	[write "calculates float *x = trunc (*y) or\n"]
	[write "returns float *b if *a is integer or\n"]
	[write "returns integer *b if *a is float.\n"]
	]
[[help e]
	[command_helper "e [*e]\n[e : *e]"]
	[write "Returns e constant.\n"]
	]
[[help pi]
	[command_helper "pi [*pi]\n[pi : *pi]"]
	[write "Returns pi constant.\n"]
	]

[[help and]
	[command_helper "and [*x *y *z]\nand [*x *y : *z]"]
	[write "Bitwise logical and (*x and *y = *z).\n"]
	[write "Works on integer parameters only.\n"]
	[write "The first two parameters can not be variables.\n"]
]

[[help or]
	[command_helper "or [*x *y *z]\nor [*x *y : *z]"]
	[write "Bitwise logical or (*x or *y = *z).\n"]
	[write "Works on integer parameters only.\n"]
	[write "The first two parameters can not be variables.\n"]
]

[[help xor]
	[command_helper "xor [*x *y *z]\nxor [*x *y : *z]"]
	[write "Bitwise logical exclusive or (*x xor *y = *z).\n"]
	[write "Works on integer parameters only.\n"]
	[write "The first two parameters can not be variables.\n"]
]

[[help rnd]
	[command_helper "rnd [*x]     [rnd : *x]    rnd [*x *from *to]"]
	[write "Generates random number.\n"]
	[write "If range specified then *from <= *x < *to.\n"]
]

[[help grnd]
	[command_helper "grnd [*x]     [grnd : *x]    grnd [*x *from *to]"]
	[write "Generic version of rnd.\n"]
	[write "Macrodefinition:\n"]
	[list grnd]
]

[[help rnd_control]
	[command_helper "rnd_control [*seed]    rnd_control [*seed *a *c]\nrnd_control [*a *c]    rnd_control [*seed *bits *a *c]"]
	[write "Controls the random number generation algorithm.\n"]
	[write "*seed is the current output.\n"]
	[write "*a is multiplier.\n"]
	[write "*c is shift.\n"]
	[write "*bits is the size of the random number.\n"]
]

[[help series]
	[command_helper "series [*from *how_many *step *seria]\nseries [*from *how_many *step : *seria]"]
	[write "Generates series of numbers arranged in random order.\n"]
	[write "If *from or *step is double then the seria consists of double numbers.\n"]
	[write "Otherwise the seria consists of integers only.\n"]
]

[[help less]
	[command_helper "less [*x *y ....]"]
	[write "Checks if *x < *y < .... .\n"]
	[write "Works on integer, float and text parameters.\n"]
]

[[help less_eq]
	[command_helper "less_eq [*x *y ....]"]
	[write "Checks if *x <= *y <= .... .\n"]
	[write "Works on integer, float and text parameters.\n"]
]

[[help greater]
	[command_helper "greater [*x *y ....]"]
	[write "Checks if *x > *y > .... .\n"]
	[write "Works on integer, float and text parameters.\n"]
]

[[help greater_eq]
	[command_helper "greater_eq [*x *y ....]"]
	[write "Checks if *x >= *y >= .... .\n"]
	[write "Works on integer, float and text parameters.\n"]
]


[[help pp]
	[command_helper "pp [*x :*y]"]
	[write "Prints all its parameters on the screen as PROLOG'S term.\n"]
	[write "In particular, it will print quotations around text parameters.\n"]
]

[[help pt]
	[command_helper "pt [*x :*y]"]
	[write "Prints all its parameters on the screen in its internal form.\n"]
	[write "In particular, it will print lists as nested pairs.\n"]
]

[[help write]
	[command_helper "write [*x :*y]"]
	[write "Prints all its parameters in the followin format:\n"]
	[write "1. Text parameters are printed without quotations.\n"]
	[write "2. Numbers are printed as ASCII characters.\n"]
	[write "3. List contents are printed as PROLOG trems.\n"]
	[write "4. All other parameters are ignored.\n"]
]

[[help nl]
	[command_helper "nl []"]
	[write "Prints a new line on the screen.\n"]
]

[[help pr]
	[command_helper "pr [*x]"]
	[write "Reads PROLOG term from the console.\n"]
]

[[help read]
	[command_helper "read [*x]"]
	[write "Reads text from the console.\n"]
	[write "First skips possible control and new line characters.\n"]
	[write "Then reads until <ENTER>.\n"]
]

[[help readln]
	[command_helper "readln [*x]"]
	[write "Reads text from the console.\n"]
	[write "Unlike \"read\", it does not skip control and new line characters.\n"]
	[write "Then reads until <ENTER>.\n"]
]

[[help list]
	[command_helper "list []   list [\"directory_name\"]   list [atom_name]"]
	[write "The behaviour of \"list\" varies depending on the parameters supplied.\n"]
	[write "Without any parameters the list of loaded directories is printed.\n"]
	[write "Text parameter lists the atome content of the directory specified.\n"]
	[write "Atom parameter lists all the clauses attached to the atom.\n"]
	[write "Try the following examples:\n"]
	[write "	list []\n"]
	[write "	list [\"studio\"]\n"]
	[write "	list [not]\n"]
]

[[help import]
	[command_helper "import [\"directory_name(.prc)\" ....]"]
	[write "Loads zero or more directories.\n"]
	[write "Does not reload a directory if it is already loaded.\n"]
	[write ".prc extension can be omitted.\n"]
]

[[help load]
	[command_helper "load [\"directory_name(.prc)\" ....]"]
	[write "Loads zero or more directories.\n"]
	[write "If a directory is already loaded then it will be reloaded.\n"]
	[write ".prc extension can be omitted.\n"]
]

[[help consult]
	[command_helper "consult [\"directory_name(.prc)\" ....]"]
	[write "Works exactly the same way as load [\"directory_name(.prc)\" ....].\n"]
	[write "However, it echoes loaded directory on the screen.\n"]
]

[[help remove_module]
	[command_helper "remove_module [\"directory_name\"]"]
	[write "Removes specified directory.\n"]
]

[[help create_module]
	[command_helper "create_module [\"directory_name\"]	create_module []"]
	[command_helper "create_module [\"directory_name\" \"service_class_name\"]"]
	[write "Creates a new directory.\n"]
	[write "Depending on parameters it may:\n"]
	[write "	create just a new directory\n"]
	[write "	create a new directory with service class\n"]
	[write "	close new directory (swap places with the first one)\n"]
]

[[help set_machine]
	[command_helper "set_machine [atom \"native_code\"]"]
	[command_helper "set_machine [atom \"service_module\" \"native_code\"]"]
	[write "Attaches machine code to specified atom.\n"]
	[write "If no service modules specified, then the first found is used.\n"]
]

[[help preprocessor]
	[command_helper "preprocessor [[]]	preprocessor [atom]"]
	[command_helper "preprocessor [*atom]	[preprocessor : *atom]"]
	[write "Sets or gets preprocessor for the root.\n"]
	[write "It does not affect private preprocessors specified in modules.\n"]
	[write "However, if there is no preprocessor defined for the root,\n"]
	[write "then it can still retrieve the first available module's preprocessor.\n"]
]

[[help prompt]
	[command_helper "prompt [*text]"]
	[command_helper "[prompt : *x]	[prompt *x]"]
	[write "Sets or gets command command prompt string.\n"]
]

;[[help crd]
;	[command_helper "crd []	crd [\"directory\"]	crd [*directory]	[crd : *directory]"]
;	[write "Changes the current root directory.\n"]
;	[write "When a variable is passed, crd returns the current root directory.\n"]
;	[write "When no parameters are passed,\n"]
;	[write "crd moves one level up within the current root directory.\n"]
;]

[[help cd]
	[command_helper "cd []	cd [\"directory\"]"]
	[write "Works as system's cd: i.e. changes the current working directory.\n"]
	[write "cd [] is an equivalent of cd [\"..\"].\n"]
]

;[[help root_directory]
;	[command_helper "root_directory []	root_directory [\"directory\"]\nroot_directory [*x]	[root_directory : *x]"]
;	[write "Changes the current root directory.\n"]
;	[write "When a variable is passed, it return the current root directory.\n"]
;	[write "Displays the current root directory when no parameter is passed.\n"]
;]

[[help add_search_directory]
	[command_helper "add_search_directory [\"directory\"]"]
	[write "Adds one more file system location to the collection of search directories.\n"]
]

[[help search_directories]
	[command_helper "search_directories []	search_directories [[]]\nsearch_directories [*x]	[search_directories : *x]\nsearch_directories[[\"d1\" \"d2\" ...]]"]
	[write "Returns or sets a list of current search directories.\n"]
	[write "Empty list removes all search directories.\n"]
	[write "Displays all search directories when no parameter is passed.\n"]
]

[[help dir]
	[command_helper "dir []	dir [\"files\"]	dir [\"files\" *files]	dir [*files]"]
	[write "Shows the content of current directory.\n"]
	[write "The exact behaviour depends on the supplied parameters.\n"]
	[write "\"files\" parameter can contain wildcards.\n"]
]

[[help edit]
	[command_helper "edit [\"file_name\"]"]
	[write "Opens a text editor for editing the specified file.\n"]
]

[[help make_file]
	[command_helper "make_file [\"file_name\"]"]
	[write "Creates a new file in the current directory.\n"]
	[write "Macrodefinition:\n"]
	[list make_file]
]

[[help make_directory]
	[command_helper "make_directory [\"directory_name\"]"]
	[write "Creates a new directory in the current directory.\n"]
]

[[help erase]
	[command_helper "erase [\"file_name\"]"]
	[write "Deletes the specified file.\n"]
]

[[help erase_directory]
	[command_helper "erase_directory [\"directory_name\"]"]
	[write "Deletes the specified directory.\n"]
]

[[help move]
	[command_helper "move [\"from\" \"to\"]"]
	[write "Moves (or renames) the specified file or directory.\n"]
]

[[help copy]
	[command_helper "copy [\"from\" \"to\"]"]
	[write "Copies the specified file.\n"]
]

[[help reload]
	[command_helper "reload []"]
	[write "Reloads the second directory on the directory list.\n"]
	[write "For example, if your \"list []\" command shows the following directories:\n"]
	[write "	user! help demo command\n"]
	[write "then the \"help\" directory will be reloaded.\n"]
	[write "Please note, that if the reloaded directory has syntax error,\n"]
	[write "then this directory will be removed.\n"]
]

[[help batch]
	[command_helper "batch [\"file_name\"]"]
	[write "Executes commands stored in a file.\n"]
	[write "Please note, that the last command in such file\n"]
	[write "must be the \"exit []\" command.\n"]
]

[[help file_reader]
	[command_helper "file_reader [atom \"file_name\"]	file_reader [*atom \"file_name\"]"]
	[write "Opens file for read and attaches a machine clause to the atom.\n"]
	[write "If a variable is passed instead of atom, then a new atom is created.\n"]
	[write "The machine clause behaves like \"pr\" reading prolog elements from the file.\n"]
	[write "Also the machine clause can accept two parameters.\n"]
	[write "In such case the first text parameters specifies the character set\n"]
	[write "for the second parameter\n"]
	[write "(i.e. [*atom \"abcdefghijklmnopqrstuvwxyz\" *text] will read only lower case texts).\n"]
	[write "To close the file, call the machine clause without parameters.\n"]
	[write "The file is closed automatically if atom is destroyed.\n"]
]

[[help file_writer]
	[command_helper "file_writer [atom \"file_name\"]	file_writer [*atom \"file_name\"]"]
	[write "Opens file for write and attaches a machine clause to the atom.\n"]
	[write "If a variable is passed instead of atom, then a new atom is created.\n"]
	[write "The machine clause behaves like \"write\" writing to the file.\n"]
	[write "To close the file, call the machine clause without parameters.\n"]
	[write "The file is closed automatically if atom is destroyed.\n"]
]

[[help CL]
	[command_helper "CL [*index *atom *clause]	CL [*atom *index *clause]	CL [*atom *index : *clause]"]
	[command_helper "CL [*atom *count]	CL [*atom : *count]"]
	[write "Retrieves the *clause attached to the *atom\n"]
	[write "at the position specified specified by *index.\n"]
	[write "It can also retrieve the total number of clauses attached\n"]
	[write "(zero if free atom).\n"]
]

[[help DELCL]
	[command_helper "DELCL [*index *atom]"]
	[write "Delete a clause attached to the *atom\n"]
	[write "at the position specified by *index.\n"]
]

[[help cl]
	[command_helper "cl [*clause]"]
	[write "Retrieves a clause that matches the parameter specified by *clause.\n"]
]

[[help OVERWRITE]
	[command_helper "OVERWRITE [*index *clause]"]
	[write "The second parameter must be a clause.\n"]
	[write "First, finds original clause based on its name.\n"]
	[write "Then deletes the original clause at the position specified by *index.\n"]
	[write "Finaly, attaches a new clause (specified by *clause)\n"]
	[write "at the same position.\n"]
]

[[help overwrite]
	[command_helper "overwrite [*clause1 *clause2]"]
	[write "Replaces *clause1 with *clause2.\n"]
	[write "Macrodefinition:\n"]
	[list overwrite]
]

[[help let]
	[command_helper "let [*atom *selector *value]"]
	[write "Manipulates on unary clauses.\n"]
	[write "The original clause should have a form of [[*atom *selector *something]].\n"]
	[write "The *something will be replaced with *value\n"]
	[write "Very usefull for implementing global variables.\n"]
	[write "Macrodefinition:\n"]
	[list let]
]

[[help addcl]
	[command_helper "addcl [*clause]	addcl [*clause *index]"]
	[write "Adds a new clause at the position specified by the index.\n"]
	[write "Adds a new clause as the last clause of the relation if position is not specified.\n"]
]

[[help addcl0]
	[command_helper "addcl0 [*clause]"]
	[write "Adds a new clause as the first clause of the relation.\n"]
]

[[help lambda]
	[command_helper "lambda [*atom *parameters : *body]"]
	[write "Creates a clause attached to *atom with *parameters and *body.\n"]
	[write "*atom can be a variable.\n"]
	[write "Very good for constructing clauses for anonymous relations.\n"]
	[write "Warning!\n"]
	[write "Referencing *atom inside *body or *parameters will cause\n"]
	[write "garbage collector to leak *atom and the entitre clause.\n"]
	[write "Macrodefinition:\n"]
	[list lambda]
]

[[help delcl]
	[command_helper "delcl [*clause]"]
	[write "Deletes the specified clause.\n"]
	[write "Macrodefinition:\n"]
	[list delcl]
]

[[help delallcl]
	[command_helper "delallcl [*atom]"]
	[write "Deletes all clauses attached to the *atom.\n"]
	[write "Macrodefinition:\n"]
	[list delallcl]
]

[[help create_atom]
	[command_helper "create_atom [*atom]\ncreate_atom [\"name\"]\ncreate_atom [\"name\" *atom]"]
	[write "Creates an atom.\n"]
	[write "Behaviour depends on the parameters supplied.\n"]
	[write "First version creates and returns an anonymous atom.\n"]
	[write "Second creates an atom with specified name.\n"]
	[write "Third version creates an atom and returns it.\n"]
]

[[help search_atom]
	[command_helper "search_atom [\"name\" *atom]"]
	[write "Searches and returns the *atom specified by \"name\".\n"]
]

[[help auto_atoms]
	[command_helper "auto_atoms []"]
	[write "Causes the interpreter to create a new atom every time\n"]
	[write "when the user specifies an unknown atom.\n"]
	[write "Sometimes usefull but can be very dangerous.\n"]
]

[[help scripted_atoms]
	[command_helper "scripted_atoms []"]
	[write "Causes the interpreter to complain every time\n"]
	[write "when the user specifies an unknown atom.\n"]
	[write "This is the default behaviour of the interpreter.\n"]
]

[[help has_machine]
	[command_helper "has_machine [*atom]"]
	[write "If parameter is an atom, then it checks if it has a machine clause attached.\n"]
	[write "if parameter is a module name, then it checks it is has a service class attached.\n"]
]

[[help is_atom]
	[command_helper "is_atom [*x]"]
	[write "Fails if the parameter is not an atom.\n"]
]

[[help is_var]
	[command_helper "is_var [*x]"]
	[write "Fails if the parameter is not a variable.\n"]
]

[[help is_text]
	[command_helper "is_text [*x]"]
	[write "Fails if the parameter is not a text.\n"]
]

[[help is_head]
	[command_helper "is_head [*x]"]
	[write "Fails if the parameter is not a memory pointer.\n"]
]

[[help is_number]
	[command_helper "is_number [*x]"]
	[write "Fails if the parameter is not a number (either integer or float).\n"]
]

[[help is_integer]
	[command_helper "is_integer [*x]"]
	[write "Fails if the parameter is not an integer.\n"]
]

[[help is_double]
	[command_helper "is_double [*x]"]
	[write "Fails if the parameter is not a float.\n"]
]

[[help e32]
	[command_helper "e32 [*number *x0 *x1 *x2 *x3]"]
	[write "Combine 4 8-bit numbers into one 32-bit numbers.\n"]
	[write "Also extracts 4 8-bit numbers from one 32-bit number.\n"]
]

[[help text_list]
	[command_helper "text_list [*text [*x1 *x2 ... *xn]]"]
	[write "Combine 8-bit ASCII characters into text.\n"]
	[write "Also extracts 8-bit ASCII characters from the text.\n"]
]

[[help text_term]
	[command_helper "text_term [*text *term]"]
	[write "Translate the *text into PROLOG term.\n"]
	[write "Also creates text representation of *term.\n"]
]

[[help wait]
	[command_helper "wait [*time]   [wait : *time]"]
	[write "Waits the specified number of milliseconds.\n"]
	[write "\"wait [0]\" causes task switch.\n"]
	[write "Also, returns the current system time in milliseconds\n"]
	[write "if variable passed.\n"]
]

[[help timeout]
	[command_helper "timeout [*time]   timeout [*time : *commands]"]
	[command_helper "timeout []        [timeout : *commands]"]
	[command_helper "[timeout []]"]
	[write "It will stop the current thread\nafter specified amount of milliseconds.\n"]
	[write "The commands (if any) will then be executed.\n"]
	[write "If time is not specified, then the current\nthread will be stopped after ZERO milliseconds.\n"]
	[write "Version with empty list cancels timeout.\n"]
	[write "Note: every subsequent timeout cancels effects of previous calls.\n"]
]

[[help timestamp]
	[command_helper "timestamp [*timestamp *year *month *day *day_of_year *day_of_week *hour *minute *second]"]
	[write "Get the current timestamp/date/time\n"]
	[write "or translate timestamp into date/time\n"]
	[write "or translate date/time into timestamp.\n"]
]

[[help wt]
	[command_helper "wt [*x]   wt []   [wt : *x]"]
	[write "Waits *x number of ticks (or one tick if no parameter specified).\n"]
	[write "Also, returns current tick if variable passed.\n"]
]

[[help beat]
	[command_helper "beat [*x]   beat []   [beat : *x]"]
	[write "Waits *x number of beats (or one beat if no parameter specified).\n"]
	[write "If fractional value specified, then it waits a relevant number of ticks\nbased on the current division settings.\n"]
	[write "Also, returns current beat (integer) if variable passed.\n"]
]

[[help bar]
	[command_helper "bar [*x]   bar []   [bar : *x]"]
	[write "Waits *x number of bars (or one bar if no parameter specified).\n"]
	[write "Also, returns current bar if variable passed.\n"]
]

[[help division]
	[command_helper "division [*beats_per_bar]\ndivision [*beats_per_bar *ticks_per_beat]"]
	[write "Controls the number of ticks in each beat and the number of beats in each bar.\n"]
	[write "Also returns current division if variable(s) passed.\n"]
]

[[help metrum]
	[command_helper "metrum [*top *bottom]"]
	[write "Sets the musical metrum.\n"]
	[write "Translates directly into \"division [*top, 96 / *bottom].\n"]
	[write "Also returns current metrum if two variables passed.\n"]
]

[[help start]
	[command_helper "start []"]
	[write "Starts the global conductor.\n"]
	[write "Fails if already started.\n"]
	]
[[help pause]
	[command_helper "pause []"]
	[write "Suspends the global conductor.\n"]
	[write "Fails if the conductor is not running.\n"]
	[write "(to resume use start)\n"]
	]
[[help stop]
	[command_helper "stop []"]
	[write "Stops the global conductor.\n"]
	[write "Fails if the conductor is not running.\n"]
	]

[[help tempo]
	[command_helper "tempo [*beats_per_minute]\ntempo [*beats *seconds]\n[tempo : *beats_per_minute]"]
	[write "Sets the musical tempo in beats per minute.\n"]
	[write "You can specify the exact number of beats per number of seconds.\n"]
	[write "Also returns current tempo if one or two variables passed.\n"]
]

[[help atempo]
	[command_helper "atempo []"]
	[write "Restores original tempo after accel or rit."]
]

[[help accel]
	[command_helper "accel []"]
	[write "Stops accelerando.\n"]
	[command_helper "accel [steps]"]
	[write "Accelerate tempo by steps.\n"]
	[command_helper "accel [steps ticks]"]
	[write "Automatically accelerate tempo per ticks.\n"]
	[command_helper "accel [steps ticks total_increase]"]
	[write "Automatically accelerate tempo per ticks\n"]
	[write "until desired total_increase achieved.\n"]
]

[[help rit]
	[command_helper "rit []"]
	[write "Stops ritardando.\n"]
	[command_helper "rit [steps]"]
	[write "Decelerate tempo by steps.\n"]
	[command_helper "rit [steps ticks]"]
	[write "Automatically decelerate tempo per ticks.\n"]
	[command_helper "rit [steps ticks total_decrease]"]
	[write "Automatically decelerate tempo per ticks\n"]
	[write "until desired total_decrease achieved.\n"]
]


[[help signal]
	[command_helper "signal []     signal [*x]"]
	[write "Signal *x number of ticks (or one tick if no parameters specified).\n"]
]

[[help signal_bar]
	[command_helper "signal_bar []      signal_bar [*x]"]
	[write "Signal *x number of bars (or one bar if no parameters sepcified).\n"]
]

[[help signal_beat]
	[command_helper "signal_beat []      signal_beat [*x]"]
	[write "Signal *x number of beats (or one beat if no parameters specified).\n"]
]

[[help reset]
	[command_helper "reset []"]
	[write "Resets the global conductor's counters [bar beat tick].\n"]
]

[[help conductor]
	[command_helper "conductor [*atom]"]
	[write "Creates an independent conductor.\n"]
	[write "If variable passed then a new atom is created.\n"]
	[write "New conductor can accept all the conductor related instructions.\n"]
	[write "Calling a new conductor without parameters deletes the conductor.\n"]
	[write "Example:\n"]
	[write "	conductor [c]\n"]
	[write "	c [start]\n"]
	[write "	c [bar 4] ... etc.\n"]
	[write "	c [] ; to close the conductor\n"]
]

[[help semaphore]
	[command_helper "semaphore [*atom]	semaphore [*atom *initial_count]"]
	[write "Creates a semaphore (if variable then a new atom is created).\n"]
	[write "Second parameter indicates initial value of semaphore (default 1).\n"]
	[write "A semaphore accepts three atoms: wait enter signal.\n"]
	[write "Calling a new semaphore without parameters deletes the semaphore.\n"]
	[write "Example:\n"]
	[write "	semaphore [s]\n"]
	[write "	s [wait]   ; to wait until signalled\n"]
	[write "	s [enter]  ; to enter immediately or fail\n"]
	[write "	s [signal] ; to signal\n"]
	[write "	s []       ; to close the semaphore\n"]
]

[[help mutex]
	[command_helper "mutex [*atom]"]
	[write "Creates a mutex (if variable then a new atom is created).\n"]
	[write "A mutex accepts three atoms: wait enter signal.\n"]
	[write "Calling a new mutex without parameters deletes the mutex.\n"]
	[write "Example:\n"]
	[write "	mutex [m]\n"]
	[write "	m [wait]   ; to wait until signalled\n"]
	[write "	m [enter]  ; to enter immediately or fail\n"]
	[write "	m [signal] ; to signal\n"]
	[write "	m []       ; to close the mutex\n"]
]

[[help monitor]
	[command_helper "monitor [*atom]"]
	[write "Creates a new clause, which operates as a monitor guarded by semaphore.\n"]
	[write "You can call monitor by providing the entry method and list of commands.\n"]
	[write "Example:\n"]
	[write "	monitor [mon]\n"]
	[write "	mon [wait [write \"...\"] ...]\n"]
	[write "Macrodefinition:\n"]
	[list monitor]
]

[[help critical_section]
	[command_helper "critical_section [[*atom : *parameters] : *commands]"]
	[write "Creates a new clause, which is guarded by internal semaphore.\n"]
	[write "Example:\n"]
	[write "	critical_section [[crit *parameter] [pp *parameter]]\n"]
	[write "	crit [127]\n"]
	[write "Macrodefinition:\n"]
	[list critical_section]
]

[[help task]
	[command_helper "task [*atom [*entry ... ] : *commands]"]
	[write "Creates a separate task, which can communicate with others\n"]
	[write "by using enter/accept/select mechanism.\n"]
	[write "Macrodefinition:\n"]
	[list task]
]

[[help enter]
	[command_helper "enter [*task *entry *parameter]"]
	[write "Basic mechanism for rendezvous with the task.\n"]
	[write "Macrodefinition:\n"]
	[list enter]
]

[[help accept]
	[command_helper "[accept *task *entry *parameter : *commands]\n[accept *task]"]
	[write "Basic mechanism for accepting rendezvous.\n"]
	[write "Version with just *task parameter is for branches,\n"]
	[write "which don't actually accept anything.\n"]
	[write "Macrodefinition:\n"]
	[list accept]
]

[[help select]
	[command_helper "[select *task *branch : *branches]"]
	[write "Basic mechanism for selecing between several accept commands.\n"]
	[write "Macrodefinition:\n"]
	[list select]
]

[[help not]
	[command_helper "[not :*x]"]
	[write "Reverses the result of its parameter call.\n"]
	[write "Macrodefinition:\n"]
	[list not]
	[write "For the sake of curiosity try: \"not [help not]\" and observe the difference.\n"]
]

[[help res]
	[command_helper "[res :*x]"]
	[write "Calls its parameters sequentially.\n"]
	[write "Macrodefinition:\n"]
	[list res]
]

[[help rres]
	[command_helper "[rres *command]"]
	[write "Matches clauses with *command in random order.\n"]
	[write "Similar to res but accepts only one call,\n"]
	[write "which is executed using clauses in random order.\n"]
	[write "Macrodefinition:\n"]
	[list rres]
]

[[help ures]
	[command_helper "[ures [*command * : *parameters]]"]
	[write "Executes clauses in random order with specified probability.\n"]
	[write "Matches clauses with [*command * : *parameters] in random order.\n"]
	[write "Similar to rres but the second parameter specifies probability.\n"]
	[write "Macrodefinition:\n"]
	[list ures]
]

[[help maximise]
	[command_helper "[maximise *x *from *to]	[maximise *x *from *to *step]"]
	[write "Generates numbers within the range, starting from the highest.\n"]
	[write "Works on integers and floating point numbers.\n"]
	[write "Macrodefinition:\n"]
	[list maximise]
]

[[help minimise]
	[command_helper "[minimise *x *from *to]	[minimise *x *from *to *step]"]
	[write "Generates numbers within the range, starting from the lowest.\n"]
	[write "Works on integers and floating point numbers.\n"]
	[write "Macrodefinition:\n"]
	[list minimise]
]

[[help lazy]
	[command_helper "[lazy : *commands]"]
	[write "Lazy evaluation.\n"]
	[write "Similar to res but may rearrange the order of commands if something fail.\n"]
	[write "Macrodefinition:\n"]
	[list lazy]
]

[[help crack]
	[command_helper "[crack :*x]"]
	[write "Splits execution into two separate threads.\n"]
	[write "Similar to \"res\", calls its parameters sequentially.\n"]
	[write "However, in a separate thread.\n"]
]

[[help eq]
	[command_helper "eq [*x *y]"]
	[write "Checks if its parameters are identical\n"]
	[write "Macrodefinition:\n"]
	[list eq]
]

[[help APPEND]
	[command_helper "APPEND [*list1 *list2 *result]"]
	[write "Combines two lists into one.\n"]
	[write "Macrodefinition:\n"]
	[list APPEND]
	]

[[help LENGTH]
	[command_helper "LENGTH [*list *length]"]
	[write "Calculates the number of elements on the list.\n"]
	[write "Can also be used to generate lists of variables with specified length.\n"]
	[write "Macrodefinition:\n"]
	[list LENGTH]
	]

[[help REVERSE]
	[command_helper "REVERSE [*original *reversed]"]
	[write "Reverses the original list.\n"]
	[write "Works both ways\n"]
	[write "(i.e. from original to reversed and from reversed to original).\n"]
	[write "Macrodefinition:\n"]
	[list REVERSE]
	]

[[help ONLIST]
	[command_helper "ONLIST [*x *list]"]
	[write "Checks if *x is a member of *list.\n"]
	[write "If backtracks then returns all consecutive elements of the *list.\n"]
	[write "Macrodefinition:\n"]
	[list ONLIST]
]

[[help INLIST]
	[command_helper "INLIST [*list *x *result]"]
	[write "Inserts *x at the beginning of *list.\n"]
	[write "If backtracks then inserts *x at different positions inside *list.\n"]
	[write "Macrodefinition:\n"]
	[list INLIST]
]

[[help NODUP]
	[command_helper "NODUP [*l1 *l2]"]
	[write "Produces *l2 *from *l1 removing duplicates.\n"]
]

[[help sort]
	[command_helper "sort [*compare_function *l1 *l2 *t]"]
	[write "Quick sort algorithm.\n"]
	[write "*ls is sorted *l1.\n"]
	[write "*t is the tail of *l2, i.e. *l2 = [1 2 3 ... : *t]."]
	[write "Sorting is based on *compare_function.\n"]
	[write "Typical usage: sort [less [1 5 8 3 6] *x []]\n"]
	[write "will produce *x = [1 3 5 6 8].\n"]
	[write "Macrodefinition:\n"]
	[list sort]
]

[[help TRY]
	[command_helper "[TRY :*x]"]
	[write "Always successes (even if failure).\n"]
	[write "Macrodefinition:\n"]
	[list TRY]
	[write "For the sake of curiosity try the following constructions:\n"]
	[write "	eq [3 4]\n"]
	[write "	eq [1 1]\n"]
	[write "	TRY [[eq 3 4]]\n"]
	[write "	TRY [[eq 1 1]]\n"]
	[write "	not [TRY [eq 3 4]]\n"]
	[write "	not [TRY [eq 1 1]]\n"]
]

[[help ONE]
	[command_helper "[ONE : *x]"]
	[write "Blocks backtracking for series of instructions.\n"]
	[write "Similar to res and /.\n"]
	[write "Macrodefinition:\n"]
	[list ONE]
]

[[help ALL]
	[command_helper "[ALL : *commands]"]
	[write "Explores all possible solutions.\n"]
	[write "Similar to res with fail.\n"]
	[write "Macrodefinition:\n"]
	[list ALL]
]

[[help PROBE]
	[command_helper "[PROBE : *x]"]
	[write "Always success.\n"]
	[write "The result of the series of instructions\n"]
	[write "is cancelled internally by fail.\n"]
	[write "Macrodefinition:\n"]
	[list PROBE]
]

[[help SELECT]
	[command_helper "[SELECT *branch : *branches]"]
	[write "Calls the first branch.\n"]
	[write "If it fails, then calls the next branch.\n"]
	[write "This is a good alternative\n"]
	[write "if several clauses are not practical.\n"]
	[write "Macrodefinition:\n"]
	[list SELECT]
]

[[help WHILE]
	[command_helper "WHILE [*condition : *action]"]
	[write "Syntactic sugar => emulates the classic \"WHILE\" loop.\n"]
	[write "Macrodefinition:\n"]
	[list WHILE]
]

[[help FOR]
	[command_helper "FOR [*index *from *to *step : *action]"]
	[write "Syntactic sugar => emulates the classic \"FOR\" loop.\n"]
	[write "Macrodefinition:\n"]
	[list FOR]
]

[[help IF]
	[command_helper "IF [*condition *action]"]
	[command_helper "IF [*condition *action *alternative]"]
	[write "Syntactic sugar => emulates the classic conditional statements.\n"]
	[write "Macrodefinition:\n"]
	[list IF]
]

[[help CONSTANT]
	[command_helper "CONSTANT [*atom *term]"]
	[write "Creates a machine clause, which stores a term permanently.\n"]
	[write "If *atom is variable, then a new atom is created.\n"]
	[write "The stored term is returned as the right element of pair.\n"]
	[write "Example:\n"]
	[write "	create_atom [\"const\"]\n"]
	[write "	CONSTANT [const [1 2 3 4]]\n"]
	[write "	res [[const : *x] [pp *x]]                => prints [1 2 3 4]\n"]
	[write "	res [[const *x *y :*z] [pp [*x *y *z]]]   => prints [1 2 [3 4]]\n"]
]

[[help VARIABLE]
	[command_helper "VARIABLE [*atom]\nVARIABLE [*atom *initial_value]"]
	[write "Creates a machine clause, which can store a term.\n"]
	[write "If *atom is variable, then a new atom is created.\n"]
	[write "If no *initial_value was passed then the initial value will be []."]
	[write "To store a term, pass it as a parameter.\n"]
	[write "To read the stored term, pass a variable as the parameter's list.\n"]
	[write "To remove machine attachment call it without parameters.\n"]
	[write "Example:\n"]
	[write "	create_atom [\"var\"]\n"]
	[write "	VARIABLE [var]\n"]
	[write "	var [127]\n"]
	[write "	res [[var : *x] [pp *x]]     => prints 127\n"]
	[write "	var []\n"]
]


[[help var]
	[command_helper "var [....]"]
	[write "Creates a number of variables.\n"]
	[write "Each variable declaration should be either:\n"]
	[write "	*x or x => variable or atom without initialization\n"]
	[write "	[*x *val] or [x *val] => initialized variable or atom\n"]
	[write "Macrodefinition:\n"]
	[list var]
]

[[help inc]
	[command_helper "inc [*atom]   inc [*atom *value]"]
	[write "Works on variables.\n"]
	[write "Increments by one or by specified value.\n"]
	[write "Macrodefinition:\n"]
	[list inc]
]

[[help dec]
	[command_helper "dec [*atom]   dec [*atom *value]"]
	[write "Works on variables.\n"]
	[write "Decrements by one or by specified value.\n"]
	[write "Macrodefinition:\n"]
	[list dec]
]

[[help ARRAY]
	[command_helper "ARRAY [*atom : *dimensions]"]
	[write "Creates a multi-dimension array, which can store terms.\n"]
	[write "If *atom is variable, then a new atom is created.\n"]
	[write "To store a term, pass it as a parameter.\n"]
	[write "To read the stored term, pass a variable as the parameter's list.\n"]
	[write "To remove machine attachment call it without parameters.\n"]
	[write "Similar to VARIABLE but every store or read operation must contains indices.\n"]
	[write "Example:\n"]
	[write "	create_atom [\"var\"]\n"]
	[write "	ARRAY [var 4 5]\n"]
	[write "	var [0 0 127]\n"]
	[write "	res [[var 0 0 : *x] [pp *x]]	=> prints 127\n"]
	[write "	var []\n"]
]

[[help ACCUMULATOR]
	[command_helper "ACCUMULATOR [*atom]"]
	[write "Creates a machine clause, which can accumulate a list of terms.\n"]
	[write "If *atom is variable, then a new atom is created.\n"]
	[write "To add a term to the list, pass it as a parameter.\n"]
	[write "To read the stored list of terms, pass a variable as the parameter's list.\n"]
	[write "To remove machine attachment call it without parameters.\n"]
	[write "Example:\n"]
	[write "	create_atom [\"accu\"]\n"]
	[write "	ACCUMULATOR [accu]\n"]
	[write "	accu [127]\n"]
	[write "	accu [128]\n"]
	[write "	accu [129]\n"]
	[write "	res [[accu : *x] [pp *x]]     => prints [129 128 127]\n"]
	[write "	accu []\n"]
]

[[help MAP]
	[command_helper "MAP [*paired_list *left_list *right_list]"]
	[write "Combines two lists into one list of pairs.\n"]
	[write "Macrodefinition:\n"]
	[list MAP]
	]

[[help ISALL]
	[command_helper "ISALL [*atom *pattern : *action]"]
	[write "Collects all the possible answers to the *action.\n"]
	[write "Each result in the form of a *pattern is added\n"]
	[write "to the ACCUMULATOR *atom.\n"]
	[write "Macrodefinition:\n"]
	[list ISALL]
]

[[help isall]
	[command_helper "isall [*list *pattern : *action]"]
	[write "Collects all the possible answers to the *action.\n"]
	[write "Each result in the form of a *pattern is added to the *list.\n"]
	[write "Macrodefinition:\n"]
	[list isall]
]

[[help isallr]
	[command_helper "isallr [*list *pattern : *action]"]
	[write "Same as isall but reverses the result list.\n"]
	[write "Macrodefinition:\n"]
	[list isallr]
]

[[help command]
	[command_helper "command []"]
	[write "Starts the command interpreter.\n"]
	[write "Works until the \"exit []\" command.\n"]
]

[[midi_helper *text *atom]
	[command_helper *text]
	[write "Sends MIDI "] [pp *atom] [write " message.\n"]
	[write "Macrodefinition:\n"]
	[list *atom]
]

[[MIDI_HELPER *text *atom]
	[command_helper *text]
	[write "Sends 14-bit MIDI "] [pp *atom] [write " control change message.\n"]
	[write "Macrodefinition:\n"]
	[list *atom]
]

[[help income_midi]
	[command_helper "income_midi [*command : *parameters]"]
	[write "Every incoming MIDI message calls this command.\n"]
	[write "The current definition of income_midi determines\n"]
	[write "the system's response to each MIDI event.\n"]
	[write "For example it may simply pass the MIDI message to the instrument:\n"]
	[write "	[[income_midi *command :*tail] [*command :*tail]]\n"]
	[write "Another example is a simple MIDI monitor:\n"]
	[write "	[[income_midi *command :*tail] [pp [*command :*tail]] [nl]]\n"]
	[write "Below is the current definition of income_midi:\n"]
	[list income_midi]
]

[[help keyoff]
	[command_helper "keyoff [*channel *key]\nkeyoff [*channel]\nkeyoff [*channel *key *velocity]"]
	[write "Sends MIDI keyoff message or controlchange message.\n"]
	[write "Macrodefinition:\n"]
	[list keyoff]
]

[[help keyon] [midi_helper "keyon [*channel *key *velocity]" keyon]]
[[help programchange] [midi_helper "programchange [*channel *program]\nprogramchange [*channel *msb_name *lsb *program]" programchange]]
[[help timingclock] [midi_helper "timingclock []" timingclock]]
[[help pitch] [midi_helper "pitch [*channel *msb]    pitch [*channel *lsb *msb]" pitch]]
[[help control] [midi_helper "control [*channel *controller *value]" control]]
[[help aftertouch] [midi_helper "aftertouch [*channel *value]" aftertouch]]
[[help polyaftertouch] [midi_helper "polyaftertouch [*channel *key *value]" polyaftertouch]]
[[help sysex]
	[command_helper "sysex [*d1 *d2 *d3 ... *dn]"]
	[write "Sends HERCs specific MIDI sysex message.\n"]
]
[[help sysexch]
	[command_helper "sysexch [*d1 *d2 *d3 ... *dn]"]
	[write "Sends HERCs specific MIDI sysex message with checksum at the end.\n"]
]
[[help SYSEX]
	[command_helper "SYSEX [*d1 *d2 *d3 ... *dn]"]
	[write "Sends MIDI sysex message.\n"]
]
[[help SYSEXCH]
	[command_helper "SYSEXCH [*d1 *d2 *d3 ... *dn]"]
	[write "Sends MIDI sysex message with checksum at the end.\n"]
]
[[help attack] [midi_helper "attack [*channel *msb]" attack]]
[[help release] [midi_helper "release [*channel *msb]" release]]
[[help holdon] [midi_helper "holdon [*channel]" holdon]]
[[help holdoff] [midi_helper "holdoff [*channel]" holdoff]]
[[help cutoff] [midi_helper "cutoff [*channel *msb]" cutoff]]
[[help resonance] [midi_helper "resonance [*channel *msb]" resonance]]
[[help mono] [midi_helper "mono [*channel]" mono]]
[[help poly] [midi_helper "poly [*channel]" poly]]
[[help bank] [midi_helper "bank [*channel *msb]\nbank [*channel *msb *lsb]\nbank [*channel *msb_name]\nbank [*channel *msb_name *lsb]" bank]]
[[help banklsb] [midi_helper "bank [*channel *lsb]" banklsb]]
[[help portaon] [midi_helper "portaon [*channel]" portaon]]
[[help portaoff] [midi_helper "portaoff [*channel]" portaoff]]
[[help portatime] [midi_helper "portatime [*channel *msb]" portatime]]
[[help volume] [midi_helper "volume [*channel *msb]" volume]]
[[help reverb] [midi_helper "reverb [*channel *msb]" reverb]]
[[help chorus] [midi_helper "chorus [*channel *msb]" chorus]]
[[help foot] [midi_helper "foot [*channel *msb]" foot]]
[[help pan] [midi_helper "pan [*channel *msb]" pan]]
[[help breath] [midi_helper "breath [*channel *msb]" breath]]
[[help modulation] [midi_helper "modulation [*channel *msb]" modulation]]
[[help CONTROL] [MIDI_HELPER "CONTROL [*channel *controller *value]" CONTROL]]
[[help ATTACK] [MIDI_HELPER "ATTACK [*channel *value]" ATTACK]]
[[help RELEASE] [MIDI_HELPER "RELEASE [*channel *value]" RELEASE]]
[[help CUTOFF] [MIDI_HELPER "CUTOFF [*channel *value]" CUTOFF]]
[[help RESONANCE] [MIDI_HELPER "RESONANCE [*channel *value]" RESONANCE]]
[[help PORTATIME] [MIDI_HELPER "PORTATIME [*channel *value]" PORTATIME]]
[[help VOLUME] [MIDI_HELPER "VOLUME [*channel *value]" VOLUME]]
[[help REVERB] [MIDI_HELPER "REVERB [*channel *value]" REVERB]]
[[help CHORUS] [MIDI_HELPER "CHORUS [*channel *value]" CHORUS]]
[[help FOOT] [MIDI_HELPER "FOOT [*channel *value]" FOOT]]
[[help PAN] [MIDI_HELPER "PAN [*channel *value]" PAN]]
[[help BREATH] [MIDI_HELPER "BREATH [*channel *value]" BREATH]]
[[help MODULATION] [MIDI_HELPER "MODULATION [*channel *value]" MODULATION]]

[[help nrpn]
	[command_helper "nrpn [*channel *pmsb *plsb *vmsb *vlsb]"]
	[command_helper "nrpn [*channel *pmsb *plsb *vmsb]"]
	[command_helper "nrpn [*channel *pmsb *plsb]"]
	[command_helper "nrpn [*channel *vmsb]"]
	[command_helper "nrpn [*channel]"]
	[write "Sends nrpn MIDI message.\n"]
	[write "Exact action depends on the parameters supplied.\n"]
	[write "Macrodefinition:\n"]
	[list nrpn]
]

[[help NRPN]
	[command_helper "NRPN [*channel *pmsb *plsb *value]"]
	[command_helper "NRPN [*channel *value]"]
	[write "Sends 14-bit nrpn MIDI message.\n"]
	[write "Macrodefinition:\n"]
	[list NRPN]
]

[[help rpn]
	[command_helper "rpn [*channel *pmsb *plsb *vmsb *vlsb]"]
	[command_helper "rpn [*channel *pmsb *plsb *vmsb]"]
	[command_helper "rpn [*channel *pmsb *plsb]"]
	[command_helper "rpn [*channel *vmsb]"]
	[command_helper "rpn [*channel]"]
	[write "Sends rpn MIDI message.\n"]
	[write "Exact action depends on the parameters supplied.\n"]
	[write "Macrodefinition:\n"]
	[list rpn]
]

;[[help RPN]
;	[command_helper "RPN [*channel *pmsb *plsb *value]"]
;	[command_helper "RPN [*channel *value]"]
;	[write "Sends 14-bit rpn MIDI message.\n"]
;	[write "Macrodefinition:\n"]
;	[list RPN]
;]

[[help hit]
	[command_helper "hit [*channel *velocity *key1 *key2 ... *keyn]"]
	[write "Sends several MIDI keyon messages.\n"]
	[write "Macrodefinition:\n"]
	[list hit]
]

[[help DCMOD]
	[command_helper "DCMOD [*diatonic *chromatic *octave *d_shift *ch_shift *d *c *o]"]
	[write "Calculates a musical interval.\n"]
	[write "Initial note is given as a combination of 3 values\n"]
	[write "(*diatonic *chromatic *octave).\n"]
	[write "Interval is given as a combination of 2 values,\n"]
	[write "which are diatonic shift and chromatic shift.\n"]
	[write "The new calculated note is given as a combination of 3 values\n"]
	[write "in similar form as the original note (*d *c *o).\n"]
]

[[help hit]
	[command_helper "hit [*channel *velocity : *keys]"]
	[write "Plays a chord. At zero velocity releases the keys.\n"]
	[write "Macrodefinition:\n"]
	[list hit]
]

[[help egcopy]
	[command_helper "egcopy [*channel *from *to]"]
	[write "Shortcut for egcopy_amp.\n"]
	[write "Macrodefinition:\n"]
	[list egcopy]
	[help egcopy_amp]
]

[[help egcopy_index]
	[command_helper "egcopy_index [*channel *from *to]"]
	[write "Copies ADSR settings for INDEX ADSR.\n"]
	[write "Macrodefinition:\n"]
	[list egcopy_index]
]

[[help egcopy_freq]
	[command_helper "egcopy_freq [*channel *from *to]"]
	[write "Copies ADSR settings for FREQ ADSR.\n"]
	[write "Macrodefinition:\n"]
	[list egcopy_freq]
]

[[help egcopy_amp]
	[command_helper "egcopy_amp [*channel *from *to]"]
	[write "Copies ADSR settings for AMP ADSR.\n"]
	[write "Macrodefinition:\n"]
	[list egcopy_amp]
]

[[help egcopy_pan]
	[command_helper "egcopy_pan [*channel *from *to]"]
	[write "Copies ADSR settings for PAN ADSR.\n"]
	[write "Macrodefinition:\n"]
	[list egcopy_pan]
]




[[help :*] [write "This section is empty at the moment.\n"]]


end.













